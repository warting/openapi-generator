/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.models

import org.openapitools.client.models.Pet
import org.openapitools.client.models.User

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName
import kotlinx.serialization.Contextual
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.SerializationException
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.buildClassSerialDescriptor
import kotlinx.serialization.json.JsonDecoder
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonEncoder
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.decodeFromJsonElement
import kotlinx.serialization.json.encodeToJsonElement

/**
 * 
 *
 */
@Serializable(with = UserOrPetSerializer::class)
sealed interface UserOrPet {
    @JvmInline
    value class UserValue(val value: User) : UserOrPet

    @JvmInline
    value class PetValue(val value: Pet) : UserOrPet

}

object UserOrPetSerializer : KSerializer<UserOrPet> {
    override val descriptor: SerialDescriptor = buildClassSerialDescriptor("UserOrPet")

    override fun serialize(encoder: Encoder, value: UserOrPet) {
        val jsonEncoder = encoder as? JsonEncoder ?: throw SerializationException("UserOrPet can only be serialized with Json")

        when (value) {
            is UserOrPet.UserValue -> jsonEncoder.encodeSerializableValue(User.serializer(), value.value)
            is UserOrPet.PetValue -> jsonEncoder.encodeSerializableValue(Pet.serializer(), value.value)
        }
    }

    override fun deserialize(decoder: Decoder): UserOrPet {
        val jsonDecoder = decoder as? JsonDecoder ?: throw SerializationException("UserOrPet can only be deserialized with Json")
        val jsonElement = jsonDecoder.decodeJsonElement()

        val errorMessages = mutableListOf<String>()

        if (jsonElement !is JsonPrimitive) {
            try {
                val instance = jsonDecoder.json.decodeFromJsonElement<User>(jsonElement)
                return UserOrPet.UserValue(instance)
            } catch (e: Exception) {
                errorMessages.add("Failed to deserialize as User: ${e.message}")
            }
        }
        if (jsonElement !is JsonPrimitive) {
            try {
                val instance = jsonDecoder.json.decodeFromJsonElement<Pet>(jsonElement)
                return UserOrPet.PetValue(instance)
            } catch (e: Exception) {
                errorMessages.add("Failed to deserialize as Pet: ${e.message}")
            }
        }

        throw SerializationException("Cannot deserialize UserOrPet. Tried: ${errorMessages.joinToString(", ")}")
    }
}

