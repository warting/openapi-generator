/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.models


import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName
import kotlinx.serialization.Contextual
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.SerializationException
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.buildClassSerialDescriptor
import kotlinx.serialization.json.JsonDecoder
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonEncoder
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.decodeFromJsonElement
import kotlinx.serialization.json.encodeToJsonElement

/**
 * 
 *
 */
@Serializable(with = StringOrLongSerializer::class)
sealed interface StringOrLong {
    @JvmInline
    value class StringValue(val value: kotlin.String) : StringOrLong

    @JvmInline
    value class LongValue(val value: kotlin.Long) : StringOrLong

}

object StringOrLongSerializer : KSerializer<StringOrLong> {
    override val descriptor: SerialDescriptor = buildClassSerialDescriptor("StringOrLong")

    override fun serialize(encoder: Encoder, value: StringOrLong) {
        val jsonEncoder = encoder as? JsonEncoder ?: throw SerializationException("StringOrLong can only be serialized with Json")

        when (value) {
            is StringOrLong.StringValue -> jsonEncoder.encodeString(value.value)
            is StringOrLong.LongValue -> jsonEncoder.encodeLong(value.value)
        }
    }

    override fun deserialize(decoder: Decoder): StringOrLong {
        val jsonDecoder = decoder as? JsonDecoder ?: throw SerializationException("StringOrLong can only be deserialized with Json")
        val jsonElement = jsonDecoder.decodeJsonElement()

        val errorMessages = mutableListOf<String>()

        if (jsonElement is JsonPrimitive && jsonElement.isString) {
            try {
                val instance = jsonDecoder.json.decodeFromJsonElement<kotlin.String>(jsonElement)
                return StringOrLong.StringValue(instance)
            } catch (e: Exception) {
                errorMessages.add("Failed to deserialize as kotlin.String: ${e.message}")
            }
        }
        if (jsonElement is JsonPrimitive && !jsonElement.isString) {
            try {
                val instance = jsonDecoder.json.decodeFromJsonElement<kotlin.Long>(jsonElement)
                return StringOrLong.LongValue(instance)
            } catch (e: Exception) {
                errorMessages.add("Failed to deserialize as kotlin.Long: ${e.message}")
            }
        }

        throw SerializationException("Cannot deserialize StringOrLong. Tried: ${errorMessages.joinToString(", ")}")
    }
}

